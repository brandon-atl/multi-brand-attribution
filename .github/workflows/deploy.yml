name: Deploy to Snowflake

on:
  push:
    branches:
      - "main"
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare runner (deps)
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ca-certificates curl libffi-dev libssl-dev

      - name: Install SnowSQL (with logs)
        id: snowsql
        continue-on-error: true
        env:
          VER: "1.2.31"
        run: |
          set -euxo pipefail
          # Use major.minor bootstrap path (1.2) with a concrete version file
          curl -fsSL "https://sfc-repo.snowflakecomputing.com/snowsql/bootstrap/1.2/linux_x86_64/snowsql-${VER}-linux_x86_64.bash" -o snowsql.bash
          bash snowsql.bash -y > snowsql_install.log 2>&1 || true
          if [ -x "$HOME/.snowsql/snowsql" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            "$HOME/.snowsql/snowsql" --version || true
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "==== SnowSQL install log tail ===="
            tail -200 snowsql_install.log || true
          fi

      - name: Show decision
        run: echo "SnowSQL available? -> ${{ steps.snowsql.outputs.ok }}"

      - name: Bootstrap schema/tables via SnowSQL
        if: steps.snowsql.outputs.ok == 'true'
        env:
          SNOWSQL_ACCOUNT:   ${{ secrets.SNOW_ACCOUNT }}
          SNOWSQL_USER:      ${{ secrets.SNOW_USER }}
          SNOWSQL_PWD:       ${{ secrets.SNOW_PASSWORD }}
          SNOWSQL_ROLE:      ${{ secrets.SNOW_ROLE }}
          SNOWSQL_WAREHOUSE: ${{ secrets.SNOW_WAREHOUSE }}
          SNOWSQL_DATABASE:  ${{ secrets.SNOW_DATABASE }}
          SNOWSQL_SCHEMA:    ${{ secrets.SNOW_SCHEMA }}
        run: |
          set -euxo pipefail

          cat > bootstrap.sql <<'SQL'
USE ROLE IDENTIFIER($SNOW_ROLE);
USE WAREHOUSE IDENTIFIER($SNOW_WAREHOUSE);
USE DATABASE IDENTIFIER($SNOW_DATABASE);
CREATE SCHEMA IF NOT EXISTS IDENTIFIER($SNOW_SCHEMA);
USE SCHEMA IDENTIFIER($SNOW_SCHEMA);

CREATE OR REPLACE TABLE DIM_BRAND (BRAND_ID INT, BRAND_CODE STRING);
CREATE OR REPLACE TABLE DIM_CHANNEL (CHANNEL_ID INT, CHANNEL_NAME STRING);
CREATE OR REPLACE TABLE DIM_CUSTOMER (CUSTOMER_ID INT, SIGNUP_UTC TIMESTAMP_NTZ, COUNTRY STRING);
CREATE OR REPLACE TABLE FACT_SESSIONS (
  SESSION_ID INT,
  CUSTOMER_ID INT,
  SESSION_UTC TIMESTAMP_NTZ,
  BRAND STRING,
  CHANNEL STRING
);
CREATE OR REPLACE TABLE FACT_ORDERS  (
  ORDER_ID INT,
  CUSTOMER_ID INT,
  ORDER_UTC TIMESTAMP_NTZ,
  BRAND STRING,
  CHANNEL STRING,
  UNITS NUMBER(9,0),
  REVENUE NUMBER(12,2),
  MARGIN NUMBER(12,2)
);
SQL

          "$HOME/.snowsql/snowsql" \
            -a "$SNOWSQL_ACCOUNT" -u "$SNOWSQL_USER" \
            -r "$SNOWSQL_ROLE" -w "$SNOWSQL_WAREHOUSE" -d "$SNOWSQL_DATABASE" \
            -o exit_on_error=true -o variable_substitution=true \
            -D SNOW_ROLE="$SNOWSQL_ROLE" \
            -D SNOW_WAREHOUSE="$SNOWSQL_WAREHOUSE" \
            -D SNOW_DATABASE="$SNOWSQL_DATABASE" \
            -D SNOW_SCHEMA="$SNOWSQL_SCHEMA" \
            -f bootstrap.sql

      - name: Seed data + create views via SnowSQL
        if: steps.snowsql.outputs.ok == 'true'
        env:
          SNOWSQL_ACCOUNT:   ${{ secrets.SNOW_ACCOUNT }}
          SNOWSQL_USER:      ${{ secrets.SNOW_USER }}
          SNOWSQL_PWD:       ${{ secrets.SNOW_PASSWORD }}
          SNOWSQL_ROLE:      ${{ secrets.SNOW_ROLE }}
          SNOWSQL_WAREHOUSE: ${{ secrets.SNOW_WAREHOUSE }}
          SNOWSQL_DATABASE:  ${{ secrets.SNOW_DATABASE }}
          SNOWSQL_SCHEMA:    ${{ secrets.SNOW_SCHEMA }}
        run: |
          set -euxo pipefail

          # Write SP + Views flush-left to avoid Python IndentationError
          cat > seed_and_views.sql <<'SQL'
USE ROLE IDENTIFIER($SNOW_ROLE);
USE WAREHOUSE IDENTIFIER($SNOW_WAREHOUSE);
USE DATABASE IDENTIFIER($SNOW_DATABASE);
USE SCHEMA IDENTIFIER($SNOW_SCHEMA);

CREATE OR REPLACE PROCEDURE GENERATE_DEMO_DATA()
RETURNS STRING
LANGUAGE PYTHON
RUNTIME_VERSION='3.10'
PACKAGES=('snowflake-snowpark-python','pandas','numpy')
HANDLER='run'
AS
$$
from snowflake.snowpark import Session
import pandas as pd
import numpy as np

def run(session: Session) -> str:
    rng = np.random.default_rng(42)
    brands   = ["JCREW","FACTORY","MADEWELL"]
    channels = ["Direct","Email","Paid Search","Social","Affiliate","Display"]

    session.create_dataframe(pd.DataFrame({"BRAND_ID":[1,2,3],"BRAND_CODE":brands})) \
           .write.mode("overwrite").save_as_table("DIM_BRAND")
    session.create_dataframe(pd.DataFrame({"CHANNEL_ID":list(range(1,7)),"CHANNEL_NAME":channels})) \
           .write.mode("overwrite").save_as_table("DIM_CHANNEL")

    N = 50000
    start = pd.Timestamp("2024-09-01 00:00:00")
    end   = pd.Timestamp("2025-08-31 23:59:59")
    span  = (end - start).total_seconds()

    signups = start + pd.to_timedelta(np.array(rng.uniform(0, span, size=N)), unit="s")
    cust = pd.DataFrame({
        "CUSTOMER_ID": np.arange(1, N+1, dtype="int64"),
        "SIGNUP_UTC":  pd.to_datetime(signups),
        "COUNTRY":     rng.choice(["US","CA","UK"], size=N, p=[.84,.10,.06])
    })
    session.write_pandas(cust, "DIM_CUSTOMER", auto_create_table=True, overwrite=True)

    rows = []
    oid = 1
    k_per = np.clip(rng.poisson(1.4, size=N), 0, 6).astype(int)

    for cid, k in zip(range(1, N+1), k_per):
        if k == 0:
            continue
        times = np.sort(start + pd.to_timedelta(rng.uniform(0, span, size=k), unit="s"))
        bsel  = rng.choice(brands,   size=k, p=[.55,.30,.15])
        chsel = rng.choice(channels, size=k, p=[.45,.12,.18,.15,.06,.04])
        for t, b, c in zip(times, bsel, chsel):
            base  = 120 if b=="JCREW" else 85 if b=="MADEWELL" else 70
            units = max(1, int(np.round(rng.gamma(2.0, 0.8))))
            price = max(25.0, float(rng.normal(base, 18)))
            rev   = round(units * price, 2)
            margin= round(rev * float(rng.uniform(0.48, 0.63)), 2)
            rows.append((oid, cid, pd.to_datetime(t), b, c, int(units), rev, margin))
            oid += 1

    df = pd.DataFrame(rows, columns=[
        "ORDER_ID","CUSTOMER_ID","ORDER_UTC","BRAND","CHANNEL","UNITS","REVENUE","MARGIN"
    ])
    df["ORDER_ID"]    = df["ORDER_ID"].astype("int64")
    df["CUSTOMER_ID"] = df["CUSTOMER_ID"].astype("int64")
    df["UNITS"]       = df["UNITS"].astype("int64")
    df["ORDER_UTC"]   = pd.to_datetime(df["ORDER_UTC"])

    session.write_pandas(df, "FACT_ORDERS", auto_create_table=True, overwrite=True)
    return f"Loaded {len(df):,} orders for {N:,} customers."
$$;

CREATE OR REPLACE VIEW VW_FIRST_PURCHASE AS
WITH first_ts AS (
  SELECT CUSTOMER_ID, MIN(ORDER_UTC) AS FIRST_ORDER_UTC
  FROM FACT_ORDERS
  GROUP BY 1
)
SELECT
  o.CUSTOMER_ID,
  o.BRAND AS FIRST_PURCHASE_BRAND,
  f.FIRST_ORDER_UTC
FROM FACT_ORDERS o
JOIN first_ts f USING (CUSTOMER_ID)
WHERE o.ORDER_UTC = f.FIRST_ORDER_UTC
QUALIFY ROW_NUMBER() OVER (PARTITION BY o.CUSTOMER_ID ORDER BY o.ORDER_UTC, o.ORDER_ID)=1;

CREATE OR REPLACE VIEW VW_BRAND_FLOWS_ANY AS
SELECT fp.FIRST_PURCHASE_BRAND AS FROM_BRAND, o.BRAND AS TO_BRAND, COUNT(DISTINCT o.CUSTOMER_ID) AS CUSTOMERS
FROM FACT_ORDERS o JOIN VW_FIRST_PURCHASE fp USING (CUSTOMER_ID)
GROUP BY 1,2;

CREATE OR REPLACE VIEW VW_BRAND_FLOWS_SUBSEQ AS
WITH first_ts AS (
  SELECT CUSTOMER_ID, MIN(ORDER_UTC) AS FIRST_ORDER_UTC
  FROM FACT_ORDERS
  GROUP BY 1
)
SELECT fp.FIRST_PURCHASE_BRAND AS FROM_BRAND, o.BRAND AS TO_BRAND, COUNT(DISTINCT o.CUSTOMER_ID) AS CUSTOMERS
FROM FACT_ORDERS o
JOIN first_ts ft USING (CUSTOMER_ID)
JOIN VW_FIRST_PURCHASE fp USING (CUSTOMER_ID)
WHERE o.ORDER_UTC > ft.FIRST_ORDER_UTC
GROUP BY 1,2;

CALL GENERATE_DEMO_DATA();
SQL

          "$HOME/.snowsql/snowsql" \
            -a "$SNOWSQL_ACCOUNT" -u "$SNOWSQL_USER" \
            -r "$SNOWSQL_ROLE" -w "$SNOWSQL_WAREHOUSE" -d "$SNOWSQL_DATABASE" \
            -o exit_on_error=true -o variable_substitution=true \
            -D SNOW_ROLE="$SNOWSQL_ROLE" \
            -D SNOW_WAREHOUSE="$SNOWSQL_WAREHOUSE" \
            -D SNOW_DATABASE="$SNOWSQL_DATABASE" \
            -D SNOW_SCHEMA="$SNOWSQL_SCHEMA" \
            -f seed_and_views.sql

      # ---------- Python fallback if SnowSQL is unavailable ----------
      - name: Setup Python for fallback
        if: steps.snowsql.outputs.ok != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Python fallback â€” deploy
        if: steps.snowsql.outputs.ok != 'true'
        env:
          SNOW_HOST:      ${{ secrets.SNOW_HOST }}
          SNOW_ACCOUNT:   ${{ secrets.SNOW_ACCOUNT }}
          SNOW_USER:      ${{ secrets.SNOW_USER }}
          SNOW_PASSWORD:  ${{ secrets.SNOW_PASSWORD }}
          SNOW_ROLE:      ${{ secrets.SNOW_ROLE }}
          SNOW_WAREHOUSE: ${{ secrets.SNOW_WAREHOUSE }}
          SNOW_DATABASE:  ${{ secrets.SNOW_DATABASE }}
          SNOW_SCHEMA:    ${{ secrets.SNOW_SCHEMA }}
        run: |
          set -euxo pipefail
          python -m pip install --upgrade pip
          python -m pip install snowflake-connector-python pandas numpy

          python - <<'PY'
          import os
          import snowflake.connector as sf

          host = os.environ.get('SNOW_HOST', '').strip()
          acct = os.environ.get('SNOW_ACCOUNT', '').strip()

          kwargs = dict(
              user=os.environ['SNOW_USER'],
              password=os.environ['SNOW_PASSWORD'],
              role=os.environ['SNOW_ROLE'],
              warehouse=os.environ['SNOW_WAREHOUSE'],
              database=os.environ['SNOW_DATABASE'],
              schema=os.environ['SNOW_SCHEMA'],
          )
          if host:
              kwargs['host'] = host
          elif acct:
              kwargs['account'] = acct
          else:
              raise RuntimeError("Provide SNOW_HOST or SNOW_ACCOUNT in repo secrets.")

          ctx = sf.connect(**kwargs)
          cs = ctx.cursor()

          def exec(sql):
              print("SQL>", sql.splitlines()[0])
              cs.execute(sql)

          # Bootstrap
          exec("CREATE SCHEMA IF NOT EXISTS " + os.environ['SNOW_SCHEMA'])
          exec("USE ROLE " + os.environ['SNOW_ROLE'])
          exec("USE WAREHOUSE " + os.environ['SNOW_WAREHOUSE'])
          exec("USE DATABASE " + os.environ['SNOW_DATABASE'])
          exec("USE SCHEMA " + os.environ['SNOW_SCHEMA'])

          # Tables
          exec("CREATE OR REPLACE TABLE DIM_BRAND (BRAND_ID INT, BRAND_CODE STRING)")
          exec("CREATE OR REPLACE TABLE DIM_CHANNEL (CHANNEL_ID INT, CHANNEL_NAME STRING)")
          exec("CREATE OR REPLACE TABLE DIM_CUSTOMER (CUSTOMER_ID INT, SIGNUP_UTC TIMESTAMP_NTZ, COUNTRY STRING)")
          exec("CREATE OR REPLACE TABLE FACT_SESSIONS (SESSION_ID INT, CUSTOMER_ID INT, SESSION_UTC TIMESTAMP_NTZ, BRAND STRING, CHANNEL STRING)")
          exec("CREATE OR REPLACE TABLE FACT_ORDERS (ORDER_ID INT, CUSTOMER_ID INT, ORDER_UTC TIMESTAMP_NTZ, BRAND STRING, CHANNEL STRING, UNITS NUMBER(9,0), REVENUE NUMBER(12,2), MARGIN NUMBER(12,2))")

          # Stored procedure (as a single string; indentation preserved correctly)
          exec(r"""
          CREATE OR REPLACE PROCEDURE GENERATE_DEMO_DATA()
          RETURNS STRING
          LANGUAGE PYTHON
          RUNTIME_VERSION='3.10'
          PACKAGES=('snowflake-snowpark-python','pandas','numpy')
          HANDLER='run'
          AS
          $$
          from snowflake.snowpark import Session
          import pandas as pd
          import numpy as np

          def run(session: Session) -> str:
              rng=np.random.default_rng(42)
              brands=["JCREW","FACTORY","MADEWELL"]
              channels=["Direct","Email","Paid Search","Social","Affiliate","Display"]

              session.create_dataframe(pd.DataFrame({"BRAND_ID":[1,2,3],"BRAND_CODE":brands})) \
                     .write.mode("overwrite").save_as_table("DIM_BRAND")
              session.create_dataframe(pd.DataFrame({"CHANNEL_ID":list(range(1,7)),"CHANNEL_NAME":channels})) \
                     .write.mode("overwrite").save_as_table("DIM_CHANNEL")

              N=50000
              start=pd.Timestamp("2024-09-01 00:00:00")
              end=pd.Timestamp("2025-08-31 23:59:59")
              span=(end-start).total_seconds()

              signups=start + pd.to_timedelta(np.array(np.random.default_rng(7).uniform(0, span, size=N)), unit="s")
              cust=pd.DataFrame({
                  "CUSTOMER_ID": np.arange(1,N+1,dtype="int64"),
                  "SIGNUP_UTC":  pd.to_datetime(signups),
                  "COUNTRY":     np.random.default_rng(1).choice(["US","CA","UK"], size=N, p=[.84,.10,.06])
              })
              session.write_pandas(cust, "DIM_CUSTOMER", auto_create_table=True, overwrite=True)

              rows=[]; oid=1
              k_per=np.clip(np.random.default_rng(3).poisson(1.4, size=N),0,6).astype(int)
              for cid,k in zip(range(1,N+1), k_per):
                  if k==0: continue
                  times=np.sort(start + pd.to_timedelta(np.random.default_rng(cid%11+4).uniform(0, span, size=k), unit="s"))
                  bsel =np.random.default_rng(5).choice(brands,   size=k, p=[.55,.30,.15])
                  chsel=np.random.default_rng(6).choice(channels, size=k, p=[.45,.12,.18,.15,.06,.04])
                  for t,b,c in zip(times,bsel,chsel):
                      base=120 if b=="JCREW" else 85 if b=="MADEWELL" else 70
                      units=max(1, int(np.round(np.random.default_rng(8).gamma(2.0,0.8))))
                      price=max(25.0, float(np.random.default_rng(9).normal(base,18)))
                      rev=round(units*price,2)
                      margin=round(rev * float(np.random.default_rng(10).uniform(0.48,0.63)),2)
                      rows.append((oid,cid,pd.to_datetime(t),b,c,int(units),rev,margin)); oid+=1

              df=pd.DataFrame(rows, columns=["ORDER_ID","CUSTOMER_ID","ORDER_UTC","BRAND","CHANNEL","UNITS","REVENUE","MARGIN"])
              df["ORDER_ID"]=df["ORDER_ID"].astype("int64")
              df["CUSTOMER_ID"]=df["CUSTOMER_ID"].astype("int64")
              df["UNITS"]=df["UNITS"].astype("int64")
              df["ORDER_UTC"]=pd.to_datetime(df["ORDER_UTC"])
              session.write_pandas(df, "FACT_ORDERS", auto_create_table=True, overwrite=True)
              return f"Loaded {len(df):,} orders for {N:,} customers."
          $$;
          """)

          # Views
          exec("""
          CREATE OR REPLACE VIEW VW_FIRST_PURCHASE AS
          WITH first_ts AS (SELECT CUSTOMER_ID, MIN(ORDER_UTC) AS FIRST_ORDER_UTC FROM FACT_ORDERS GROUP BY 1)
          SELECT o.CUSTOMER_ID, o.BRAND AS FIRST_PURCHASE_BRAND, f.FIRST_ORDER_UTC
          FROM FACT_ORDERS o JOIN first_ts f USING (CUSTOMER_ID)
          WHERE o.ORDER_UTC = f.FIRST_ORDER_UTC
          QUALIFY ROW_NUMBER() OVER (PARTITION BY o.CUSTOMER_ID ORDER BY o.ORDER_UTC, o.ORDER_ID)=1
          """)

          exec("""
          CREATE OR REPLACE VIEW VW_BRAND_FLOWS_ANY AS
          SELECT fp.FIRST_PURCHASE_BRAND AS FROM_BRAND, o.BRAND AS TO_BRAND, COUNT(DISTINCT o.CUSTOMER_ID) AS CUSTOMERS
          FROM FACT_ORDERS o JOIN VW_FIRST_PURCHASE fp USING (CUSTOMER_ID) GROUP BY 1,2
          """)

          exec("""
          CREATE OR REPLACE VIEW VW_BRAND_FLOWS_SUBSEQ AS
          WITH first_ts AS (SELECT CUSTOMER_ID, MIN(ORDER_UTC) AS FIRST_ORDER_UTC FROM FACT_ORDERS GROUP BY 1)
          SELECT fp.FIRST_PURCHASE_BRAND AS FROM_BRAND, o.BRAND AS TO_BRAND, COUNT(DISTINCT o.CUSTOMER_ID) AS CUSTOMERS
          FROM FACT_ORDERS o JOIN first_ts ft USING (CUSTOMER_ID) JOIN VW_FIRST_PURCHASE fp USING (CUSTOMER_ID)
          WHERE o.ORDER_UTC > ft.FIRST_ORDER_UTC GROUP BY 1,2
          """)

          exec("CALL GENERATE_DEMO_DATA()")
          cs.close(); ctx.close()
          PY
